format ELF64 executable 3

macro do_syscall sys_call_number
{
    mov rax, sys_call_number
    syscall
}

macro syscall3 sys_call_number, arg0, arg1, arg2
{
    mov rdx, arg2
    mov rsi, arg1
    mov rdi, arg0
    do_syscall sys_call_number
}

macro syscall2 sys_call_number, arg0, arg1
{
    mov rsi, arg1
    mov rdi, arg0
    do_syscall sys_call_number
}

macro syscall1 sys_call_number, arg0
{
    mov rdi, arg0
    do_syscall sys_call_number
}

macro function_save_stack
{
    push rbp
    mov rbp, rsp
}

macro function_load_stack
{
    mov rsp, rbp
    pop rbp
}

macro breakpoint
{
    int3
}

stdin = 0
stdout = 1
stderr = 2

sys_read = 0
sys_write = 1
sys_exit = 60

endl = 10

segment readable executable


macro exit code
{
    push rax rsi
    syscall1 sys_exit, code
    pop rsi rax
}


macro input buffer, length
{
    push rdi rsi rdx
    syscall3 sys_read, stdin, buffer, length
    pop rdx rsi rdi
}


macro print_str buffer, length
{
    push rax rdi rsi rdx
    syscall3 sys_write, stdout, buffer, length
    pop rdx rsi rdi rax
}


print_int:  ; rax number input
    push rax rdi rsi

    lea rdi, [number_string_buffer]
    call string_from_number

    mov [number_string_buffer + rsi], endl
    inc rsi
    print_str number_string_buffer, rsi

    pop rsi rdi rax

    ret


number_from_string:  ; rdi buff, rsi buff_length, returns rax number
    push rsi

    mov rax, 0  ; result
    ; rsi - counter
    mov rcx, 1  ; 10's powers

    cmp rsi, 0
    je number_from_string_end_reading

    push rbx rcx

  number_from_string_read_one_digit:
    dec rsi

    movzx rbx, byte [rdi + rsi]

    cmp rbx, 0
    je number_from_string_read_one_digit

    cmp rbx, endl
    je number_from_string_read_one_digit

    cmp rbx, ' '
    je number_from_string_read_one_digit

    sub rbx, '0'
    imul rbx, rcx
    add rax, rbx
    imul rcx, 10

    cmp rsi, 0
    jne number_from_string_read_one_digit

  number_from_string_end_reading:
    pop rcx rbx

    pop rsi

    ret


string_from_number:  ; rax number, rdi buff, rsi characters written
    push rax

    mov rsi, 0

    cmp rax, 0
    jne string_from_number_main

    inc rsi
    mov [rdi], byte '0'

    jmp string_from_number_end
  string_from_number_main:

    repeat 20  ; 2^64 = 18446744073709551616
        ; rax - Dividend
        mov rdx, 0 ; High order bits of the dividend
        mov rcx, 10 ; Divisor
        idiv rcx    ; Perform the division
        ; rax contains the quotient and rdx contains the remainder

        add rdx, '0'
        mov [rdi + rsi], dl
        inc rsi

        cmp rax, 0
        je string_from_number_div_end
    end repeat

  string_from_number_div_end:

    push r8 r9

    ; flip the generated bytes
    ; here i can mess with rax as much as i want, i don't need it anymore
    mov r8, 0
    mov r9, rsi
    dec r9
  string_from_number_flip:

    mov al, [rdi + r8]
    xchg al, [rdi + r9]
    xchg al, [rdi + r8]

    inc r8
    dec r9
    cmp r8, r9
    jle string_from_number_flip

    pop r9 r8

  string_from_number_end:
    pop rax

    ret


factorial:  ; rax number input and output
    cmp rax, 1
    jg factorial_calculate

    ; return one
    mov rax, 1
    jmp factorial_end

  factorial_calculate:
    push rsi
    mov rsi, rax

  factorial_calculate_one:
    dec rsi
    imul rax, rsi

    cmp rsi, 1
    jg factorial_calculate_one

    pop rsi

  factorial_end:
    ret


entry main
main:
    print_str enter_a_number, enter_a_number_length

    input buff, buff_length

    print_str got_a_string, got_a_string_length

    print_str buff, buff_length

    lea rdi, [buff]
    mov rsi, rax
    call number_from_string

    print_str got_number_from_string, got_number_from_string_length

    call print_int

    call factorial

    print_str calculation_result, calculation_result_length

    call print_int

    exit 0

segment readable writable

    enter_a_number db 'Enter a number: '
    enter_a_number_length = $-enter_a_number

    got_a_string db 'Got a string: '
    got_a_string_length = $-got_a_string

    got_number_from_string db 'Got number from a string: '
    got_number_from_string_length = $-got_number_from_string

    calculation_result db 'Calculation result: '
    calculation_result_length = $-calculation_result

    space db ' '
    space_length = $-space

    buff rb 128
    buff_length = $-buff

    number_string_buffer rb 32

; display/i $pc
